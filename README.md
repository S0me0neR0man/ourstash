# NoSQL in-memory БД

## Зачем
Данные хранимые в БД можно разделить на две большие группы:
1. Метаданные: настройки приложения, настройки бизнес-процессов, сюда же стоит отнести различные 
справочники, "мапинги" и др. Метаданные непосредственно в продуктивных системах обычно не изменяются, 
их корректировка это по сути разработка. Для метаданных важно иметь историю изменений, а еще лучше 
систему контроля версий и возможность "зарелизить" (аналог pull request) изменения в ПРОМ.
2. Собственно данные приложения. Здесь хочется избежать ресурсоёмких операций преобразования данных между 
приложением и БД. Кроме того, если мы захотим иметь локальные копии некоторой общей БД (привет GophKeeper), 
и иметь возможность "с-merge-ить" изменения, то контроль версий и тут пригодится.

Обычно целостность и непротиворечивость данных обеспечивается либо с помощью транзакций (реляционные СУБД)
либо с помощью атомарных операций (NoSQL БД). Известны "узкие места" обоих подходов.

Что предлагается:
1. Целостность данных = контроль версий:
   * рабочая ветка данных гарантирует только атомарный доступ к полям по ключу
   * commit фиксирует изменения в ветке, после чего гарантируется целостность данных
   * по аналогии с системами контроля версий должны быть доступны операции checkout, merge 
   (--squash само собой) и т.д.
2. Данные хранятся в памяти (in-memory БД), и в том виде в каком они представлены в приложении 

**Горизонтально масштабируемая архитектура плюс качественный контроль целостности данных.**

Итого хочется иметь из коробки:
* Многопользовательская БД для использования которой достаточно выполнить import соответствующих компонентов
* Контроль версий и история изменений
* Для отдельных разделов данных иметь возможность отключить ненужное и минимизировать время выполнения операций 
чтения/записи
* Индекс в виде сбалансированного двоичного дерева для быстрого поиска по ключу

## Общий подход
Данные хранятся в виде `ключ`-`значение` </br>
Уровнем выше следующая логическая структура:
- БД состоит из секций (далекая аналогия - таблицы реляционной БД), секция 0 системная
- В каждой секции множество записей (ид записи - автоинкремент `uint64`). Нулевая запись системная.
- Для каждой записи хранится история изменений (при создании генерируется guid, update создает новую запись с тем же
guid, старая запись помечается как удаленная + в заголовке старой сохраняется ид новой записи)
- Запись состоит из произвольного набора полей. Пользовательский идентификатор поля `string`, внутренний ид `uint16`.
Внутренние идентификаторы создаются один раз и никогда не изменяются.
- контроль версий на уровне записей (не полей).
- Для быстрого поиска реализовано `redBlackTree`. 
- Публичные методы потокобезопасные. 

## Хранение данных
```
const KeyLength = 16
type Key [keyLength]byte
```

| секция</br> [0:1] </br> | запись</br> [1:9] | поле</br> [9:11] | значение                  |
|:------------------------|:------------------|:-----------------|:--------------------------|
| N                       | 0x00000000        | 0x0000           | автоинкремент id          |
| 0x00                    | 0x00000001        | > 0              | todo: user private key    |
| N                       | 0x00000000        | > 0              | пользовательские ид полей |
| N                       | M                 | 0x0000           | `recordHeader`            |
| N                       | M                 | R                | значение поля             |

## Пользователи, аутентификация
Аутентификация пользователей базируется на использовании одноразовых паролей (One-time Password, OTP) 
[RFC4226](https://www.rfc-editor.org/rfc/rfc4226) и JWT токенов. При создании пользователя генерируется 
shared secret key. На стороне сервера ключ хранится в БД вместе с другой информацией о пользователе, 
клиент свой ключ хранит в приложении google authenticator. Планируется разработка веб приложения администрирования 
пользователей включающее функционал аналогичный [FreeOTP](https://freeotp.github.io/qrcode.html). 

Клиент обращается к сервису аутентификации с логином и одноразовым паролем, и если пароль корректен, то в ответ 
получает JWT токен.


## TODO:

1. Пользователи, аутентификация 
2. Конфиги, запись/чтение данных на диск
3. Просмотр истории изменений 
4. Производительность/многозадачность
5. Рефакторинг/Ренэйминг
6. Контроль версий 
7. Администрирование

